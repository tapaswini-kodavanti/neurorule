version: "1.0"

steps:

    clone-repo:
        type: git-clone
        title: "Clone ${{CF_REPO_NAME}} repo"
        repo: "${{CF_REPO_OWNER}}/${{CF_REPO_NAME}}"
        git: github
        revision: "${{CF_REVISION}}"
        depth: 0  # Fetch full history, not a shallow clone

    determine_latest_git_tag:
        title: "Determine Latest Git tag"
        description: "Find the current git tag for use later in pipeline"
        type: "freestyle"
        image: alpine/git:v2.30.0
        working_directory: ${{CF_VOLUME_PATH}}/${{CF_REPO_NAME}}
        commands:
          - cf_export SETUPTOOLS_SCM_PRETEND_VERSION=`git tag --sort=-v:refname | head -n 1`

    prepare_for_build:
        description: "Do any common preparation for tests"
        type: "freestyle"
        image: alpine:3.13.1
        working_directory: ${{CF_VOLUME_PATH}}/${{CF_REPO_NAME}}
        commands:
            # Set up some variables

            # It's our experience the the CF_VOLUME can leak between builds
            # Attempt to do some isolation.
            - export TEMP_DIR_OUTSIDE_CONTAINER=${{CF_VOLUME_PATH}}/tmp/${{CF_BUILD_ID}}
            - mkdir -p ${TEMP_DIR_OUTSIDE_CONTAINER}

            - export APP_HOME=/home/${{CF_REPO_OWNER}}
            - export APP_SOURCE=${APP_HOME}/${{CF_REPO_NAME}}

            # cf_export these variables so these vars can be used in later build steps
            - cf_export TEMP_DIR_OUTSIDE_CONTAINER APP_HOME APP_SOURCE

            # set the wheel package name which is the
            # the repo name, but with underscores instead of dashes
            # Differences from standard build-template:
            #   The repo name is "evolution-service", but the package produced has historically
            #   been called "esp_service"
            # - cf_export PACKAGE_NAME=`echo ${{CF_REPO_NAME}} | sed s/-/_/g`
            - cf_export PACKAGE_NAME=esp_service

    # Use image name to push/pull from our ecr.
    # This image name is the ecr repository name
    # for which we can control important variables such as
    # lifecycle policy. The tag for default case will be
    # the git SHA. Non-master builds go to the junk repo
    # called 'intermediate'.
    set_push_variables:
        title: "Setup the image name and tag for default case"
        image: python:3.10-slim
        commands:
            - export IMG_NAME=intermediate
            - export TAG=${{CF_REVISION}}
            - cf_export IMG_NAME
            - cf_export TAG

    # For builds of master that are not official releases,
    # we push an image to a separate repo
     # and that image is used for integration testing. This
    # repo allows mutable tags and should generally
    # only contain the most recent master build.
    set_push_variables_master:
        title: "Setup the image name and tag for master branch, not release"
        image: python:3.10-slim
        commands:
            - export IMG_NAME=esp/esp_master
            - export TAG=integration_test
            - cf_export IMG_NAME
            - cf_export TAG
        when:
            branch:
                only:
                    - master

    # When codefresh sets the CF_RELEASE_TAG, this task will run
    # and switch the push variables to their production values.
    # The resulting container is pushed to the production
    # repo in ecr (with immutable tagging to prevent overwrite).
    set_push_variables_release:
        title: "Change variables for release build"
        image: python:3.10-slim
        commands:
            - export IMG_NAME=esp
            - export TAG=${{CF_RELEASE_TAG}}
            - cf_export IMG_NAME
            - cf_export TAG
        when:
            condition:
                all:
                    # This is idiomatic Codefresh for detecting if ${{CF_RELEASE_TAG}}
                    # has a value. We only want to deploy on Github release triggers,
                    # and this variable gets populated only for Github releases.
                    deploy_tagged_builds_only: 'includes("${{CF_RELEASE_TAG}}", "{{CF_RELEASE_TAG}}") == false'

    create-temp-git-creds-from-vault:
        title: "Get ephemeral GitHub creds"
        description: "Get temporary git credentials from vault server.
                      Create credential for use in docker secret with_creds_requirements"
        type: "freestyle"
        image: "vault:1.12.0"
        working_directory: ${{CF_VOLUME_PATH}}/${{CF_REPO_NAME}}

        # Disable all caching for this step to ensure the requirements file
        # is always up to date. This step is very quick so the time hit
        # is minimal.
        # disable docker local cache
        no_cache: true
        # disable codefresh additional caching mechanisms
        no_cf_cache: true

        commands:
            # Specifically use the temp directory outside the container we want to build
            # so as not to accidentally copy sensitive credentials inside of it.
            - export WITH_CREDS_REQUIREMENTS=${{TEMP_DIR_OUTSIDE_CONTAINER}}/with_creds_requirements.txt
            - cp requirements-private.txt ${WITH_CREDS_REQUIREMENTS}
            - cf_export WITH_CREDS_REQUIREMENTS

            # Login into Vault only once
            - >-
                vault login -address=${{VAULT}} -method=github token=${{VAULT_LOGIN}}
                | grep -Ev "(token |token_accessor)"

            # Get the ephemeral token for public repos
            - EPHEMERAL_TOKEN=$(vault read -address=${{VAULT}} -field=token /github-secrets/token/repo-read)
            - EPHEMERAL_LEAF_SOURCE_CREDENTIALS="x-access-token:${EPHEMERAL_TOKEN}"
            - >-
                sed -i "s/\${LEAF_SOURCE_CREDENTIALS}/${EPHEMERAL_LEAF_SOURCE_CREDENTIALS}/g"
                ${WITH_CREDS_REQUIREMENTS}

            # Get the ephemeral token for private repos
            - EPHEMERAL_TOKEN=$(vault read -address=${{VAULT}} -field=token /github-private-secrets/token/repo-read)
            - EPHEMERAL_LEAF_PRIVATE_SOURCE_CREDENTIALS="x-access-token:${EPHEMERAL_TOKEN}"
            - >-
                sed -i "s/\${LEAF_PRIVATE_SOURCE_CREDENTIALS}/${EPHEMERAL_LEAF_PRIVATE_SOURCE_CREDENTIALS}/g"
                ${WITH_CREDS_REQUIREMENTS}

    repo_build:
        title: "Building Docker image for ${{CF_REPO_NAME}}"
        type: "build"
        # Differences from standard build-template:
        #   We need to use IMG_NAME nad TAG so that builds from various points of origin can be successful
        # image_name: "leaf/${{CF_REPO_NAME}}"
        # tag: ${{CF_BRANCH_TAG_NORMALIZED}}-${{CF_SHORT_REVISION}}
        image_name: ${{IMG_NAME}}
        tag: ${{TAG}}
        working_directory: ${{CF_VOLUME_PATH}}/${{CF_REPO_NAME}}
        dockerfile: "build_scripts/Dockerfile"
        # Differences from standard build-template:
        #   If we don't push these images, the integration test flow won't work.
        # disable_push: true
        buildkit: true
        # Docker BuildKit has different output. This progress plain allows
        # us to see the "old" style output which is useful.
        progress: "plain"
        # The src refers to our secret file on the host system. Within the
        # dockerfile we refer to the secret by id. By not providing a dst
        # the file ends up at the docker default of /run/secrets/<id>
        secrets:
            - id=with_creds_requirements,src=${{WITH_CREDS_REQUIREMENTS}}
        build_arguments:
            - REPO=${{CF_REPO_NAME}}
            - USERNAME=${{CF_REPO_OWNER}}
            - APP_HOME=${{APP_HOME}}
            - APP_SOURCE=${{APP_SOURCE}}

    run_all_tests:
        type: parallel
        fail_fast: false
        steps:
            run_pylint:
                title: Run pylint
                # Use the image created by the repo_build step above
                # See: https://codefresh.io/docs/docs/codefresh-yaml/variables/
                image: ${{repo_build}}
                description: "Run Pylint"
                # Specifically run in the APP_SOURCE directory inside the container,
                # *not* in the CF_VOLUME as we had erroneously done before.
                working_directory: ${{APP_SOURCE}}
                # Allow the pipeline to continue if this step fails
                fail_fast: false
                commands:
                    - pip3 freeze
                    - build_scripts/run_pylint.sh

            run_flake8:
                title: Run flake8
                # Use the image created by the repo_build step above
                # See: https://codefresh.io/docs/docs/codefresh-yaml/variables/
                image: ${{repo_build}}
                description: "Run Flake8"
                # Specifically run in the APP_SOURCE directory inside the container,
                # *not* in the CF_VOLUME as we had erroneously done before.
                working_directory: ${{APP_SOURCE}}
                # Allow the pipeline to continue if this step fails
                fail_fast: false
                commands:
                    - pip3 freeze
                    # See repo ~/.flake8 file for settings
                    - flake8

            run_shellcheck:
                title: Run Static Analysis on Shell Scripts
                description: "Run shellcheck tool on our shell scripts"
                type: "freestyle"
                # Use the image created by the repo_build step above
                # See: https://codefresh.io/docs/docs/codefresh-yaml/variables/
                image: ${{repo_build}}
                # Specifically run in the APP_SOURCE directory inside the container,
                # *not* in the CF_VOLUME as we had erroneously done before.
                working_directory: ${{APP_SOURCE}}
                fail_fast: false
                commands:
                    - ./build_scripts/run_shellcheck.sh

            run_unit_tests:
                title: Run unit tests
                # Use the image created by the repo_build step above
                # See: https://codefresh.io/docs/docs/codefresh-yaml/variables/
                image: ${{repo_build}}
                description: Run unit tests (pytests)
                # Specifically run in the APP_SOURCE directory inside the container,
                # *not* in the CF_VOLUME as we had erroneously done before.
                working_directory: ${{APP_SOURCE}}
                fail_fast: false
                commands:
                    - pip3 freeze
                    - pytest --version
                    - >
                      pytest
                      --verbose
                      -m "not integration"
                      --timer-top-n 10
                      --cov=${PACKAGE_NAME}

    clean_up:
        description: "Clean up after ourselves"
        type: "freestyle"
        image: alpine:3.13.1
        working_directory: ${{CF_VOLUME_PATH}}/${{CF_REPO_NAME}}
        commands:
            # Clean up anything senstive we do not want to leak between builds
            - rm -rf ${{TEMP_DIR_OUTSIDE_CONTAINER}}
            - rm -rf ${{CF_VOLUME_PATH}}/${{CF_BUILD_ID}}

    all_test_status:
        title: Check For Failed Tests
        description: "Handle any fail cases that may have occurred"
        image: alpine:3.13.1
        commands:
            - exit 1
        when:
            condition:
                any:
                    static_test_fail:
                        steps.run_pylint.result == "failure" ||
                        steps.run_flake8.result == "failure" ||
                        steps.run_shellcheck.result == "failure" ||
                        steps.run_unit_tests.result == "failure" ||
                        steps.run_all_tests.result == "failure"

    build_wheel:
        title: Build wheel file
        image: ${{repo_build}}
        shell: bash
        description: Build wheel file for distribution
        working_directory: ${{APP_SOURCE}}
        commands:
            - python -m build --wheel
            - mkdir -p ${{CF_VOLUME_PATH}}/${{CF_BUILD_ID}}
            - cd dist && mv ${PACKAGE_NAME}*.whl ${{CF_VOLUME_PATH}}/${{CF_BUILD_ID}}

    upload-to-S3:
        title: Upload Wheel to S3
        type: aws-s3
        arguments:
            REGION: us-west-2
            BUCKET: ${{UNILEAF_WHEEL_BUCKET}}
            S3_INTEGRATION: amazon
            S3_PREFIX: ${{PACKAGE_NAME}}/
            SOURCE: ${{CF_VOLUME_PATH}}/${{CF_BUILD_ID}}
        when:
            condition:
                all:
                # This is idiomatic Codefresh for detecting if ${{CF_RELEASE_TAG}} has a value. We only want to deploy
                # on Github release triggers, and this variable gets populated only for Github releases.
                    deploy_tagged_builds_only: 'includes("${{CF_RELEASE_TAG}}", "{{CF_RELEASE_TAG}}") == false'

    # Trigger the integration test for master
    # branch that is not a release.
    run_integration_pipeline:
        title: Trigger Integration Pipeline
        type: codefresh-run
        arguments:
            PIPELINE_ID: esp/ESP-integration-tests-master
            VARIABLE:
                - CF_REVISION=${{CF_REVISION}}
        when:
            condition:
                all:
                    integration_test: '"${{TAG}}" == "integration_test"'
