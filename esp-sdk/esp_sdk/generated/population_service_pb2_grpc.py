# Copyright (C) 2019-2023 Cognizant Digital Business, Evolutionary AI.
# All Rights Reserved.
# Issued under the Academic Public License.
#
# You can be released from the terms, and requirements of the Academic Public
# License by purchasing a commercial license.
# Purchase of a commercial license is mandatory for any use of the
# esp-sdk SDK Software in commercial settings.
#
# END COPYRIGHT
# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from . import population_structs_pb2 as population__structs__pb2


class PopulationServiceStub(object):
    """Note: lifted from https://github.com/leaf-ai/deepbilevel/tree/master/servicecommon/service/protos
    At some point we will reconcile with ENN/LEAF but for now these are copy-pasted.


    The service definition for a generic population server.

    If creating a population can take longer than 30-45 seconds,
    Some implementations of a population service might require an
    implementation of a Submission service also with the same API.

    The Submission Service has the same interface as the underlying
    Population Service.  It will call the underlying Population Service
    to ask it to create a population, but since this can take awhile,
    this service returns early with information as to how further updates can
    be obtained via subsequent GetPopulation() calls: an "Is it there yet?" poll.
    This allows the long (> 1 min) idle sockets to close with service work
    still proceeding.

    Even though the Submission Service has the same interface as the
    Population Service itself, you would need to define a separate service
    for it so requests can be routed differently within the service cluster.

    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.NextPopulation = channel.unary_unary(
                '/population.PopulationService/NextPopulation',
                request_serializer=population__structs__pb2.PopulationRequest.SerializeToString,
                response_deserializer=population__structs__pb2.PopulationResponse.FromString,
                )
        self.GetPopulation = channel.unary_unary(
                '/population.PopulationService/GetPopulation',
                request_serializer=population__structs__pb2.ExistingPopulationRequest.SerializeToString,
                response_deserializer=population__structs__pb2.PopulationResponse.FromString,
                )


class PopulationServiceServicer(object):
    """Note: lifted from https://github.com/leaf-ai/deepbilevel/tree/master/servicecommon/service/protos
    At some point we will reconcile with ENN/LEAF but for now these are copy-pasted.


    The service definition for a generic population server.

    If creating a population can take longer than 30-45 seconds,
    Some implementations of a population service might require an
    implementation of a Submission service also with the same API.

    The Submission Service has the same interface as the underlying
    Population Service.  It will call the underlying Population Service
    to ask it to create a population, but since this can take awhile,
    this service returns early with information as to how further updates can
    be obtained via subsequent GetPopulation() calls: an "Is it there yet?" poll.
    This allows the long (> 1 min) idle sockets to close with service work
    still proceeding.

    Even though the Submission Service has the same interface as the
    Population Service itself, you would need to define a separate service
    for it so requests can be routed differently within the service cluster.

    """

    def NextPopulation(self, request, context):
        """Returns an initial or new generation specification
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetPopulation(self, request, context):
        """Returns an existing population of the experiment
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_PopulationServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'NextPopulation': grpc.unary_unary_rpc_method_handler(
                    servicer.NextPopulation,
                    request_deserializer=population__structs__pb2.PopulationRequest.FromString,
                    response_serializer=population__structs__pb2.PopulationResponse.SerializeToString,
            ),
            'GetPopulation': grpc.unary_unary_rpc_method_handler(
                    servicer.GetPopulation,
                    request_deserializer=population__structs__pb2.ExistingPopulationRequest.FromString,
                    response_serializer=population__structs__pb2.PopulationResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'population.PopulationService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class PopulationService(object):
    """Note: lifted from https://github.com/leaf-ai/deepbilevel/tree/master/servicecommon/service/protos
    At some point we will reconcile with ENN/LEAF but for now these are copy-pasted.


    The service definition for a generic population server.

    If creating a population can take longer than 30-45 seconds,
    Some implementations of a population service might require an
    implementation of a Submission service also with the same API.

    The Submission Service has the same interface as the underlying
    Population Service.  It will call the underlying Population Service
    to ask it to create a population, but since this can take awhile,
    this service returns early with information as to how further updates can
    be obtained via subsequent GetPopulation() calls: an "Is it there yet?" poll.
    This allows the long (> 1 min) idle sockets to close with service work
    still proceeding.

    Even though the Submission Service has the same interface as the
    Population Service itself, you would need to define a separate service
    for it so requests can be routed differently within the service cluster.

    """

    @staticmethod
    def NextPopulation(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/population.PopulationService/NextPopulation',
            population__structs__pb2.PopulationRequest.SerializeToString,
            population__structs__pb2.PopulationResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def GetPopulation(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/population.PopulationService/GetPopulation',
            population__structs__pb2.ExistingPopulationRequest.SerializeToString,
            population__structs__pb2.PopulationResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
